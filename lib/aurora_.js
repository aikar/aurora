var
  fs         = require('fs'),
  path       = require('path'),
  traceur    = require('traceur/lib/transform.js'),
  streamline = require('streamline/lib/compiler/transform.js'),
  exec       = require('child_process').exec;
  
var directoryIgnoreList = ['CVS','.svn','.git','.hg','.bzr'];

/**
 * Checks if the file is compiled already, and returns the contents if so.
 *
 * @param string input source file to translate
 * @param string output file to save/compare to
 * @param string banner that should be written
 * @param object project settings
 * @return string|bool Is the file up to date
 */
function isAlreadyCompiled(input, output, banner, project) {
  // does output file exists
  var outstat = mtime(output);
  if (!outstat) {
    return false;
  }
  
  // is input newer than output?
  var inpstat = mtime(input);
  if (inpstat > outstat) {
    return false;
  }
  
  // does the banners match?
  var oldContent = fs.readFileSync(output).toString();
  if (oldContent.substr(0, banner.length) !== banner) {
    return false;
  }
  
  // its really compiled already...
  return oldContent;
}
function compileFile(input, project) {
  var ext = project.extension;
  if (input.substr(input.length - ext.length) !== ext) {
    return null;
  }
  var output = input.substr(0, input.length - ext.length) + '.js';
  var options = project.streamlineoptions;
  var content = fs.readFileSync(input).toString();
  
  var SB = parseShebang(content);
  var shebang = SB[0],
      le      = SB[2],
      banner  = "/**:" +
                "Compiled with Aurora v" + project.auroraVersion + " with Streamline and Traceur Compilers. --" +
                "DO NOT EDIT THIS FILE!!! Edit " + path.basename(input) +
                " instead and recompile with Aurora! :*/";
  
  if ((oldContent = isAlreadyCompiled(input, output, shebang + le + banner, project))) {
    return [output, oldContent];
  }
  
  // strip shebang if exists and replace with a newline to keep line count correct.
  content = le + SB[1];
  
  // transform Traceur
  content = traceur(content, input);
  // transform Streamline
  content = streamline.transform(content, options);
  
  // add shebang back in if it existed.
  content = SB[0] + le + banner + content;
  
  // write back to file
  fs.writeFileSync(output, content);
  if (project.verbose) console.log("Successfully transformed", input.replace(process.cwd()+'/',''), "to", output.replace(process.cwd()+'/', ''));
  return [output, content];
}

var project = null;
function getProject() {
  if (project) {
    return project;
  }
  var base = process.cwd();
  try {
    var packagejson = fs.readFileSync(base + "/package.json").toString();
    var pkg = JSON.parse(packagejson);
  } catch (e) {
    e.message = "Error parsing package.json, you really should make one for your project!" + e.message;
    throw e;
  }
  var projectjson = fs.readFileSync(base + "/aurora.json").toString();
  project = JSON.parse(projectjson);
  project.auroraVersion = pkg.version;
  
  project.extension = project.extension || '_.js';
  if (project.dirs && Array.isArray(project.dirs)) {
    project.dirs = project.dirs.map(function(dir) {
      return path.resolve(base, dir);
    });
  } else {
    throw new Error("aurora.json needs a minimum of a dirs key (array of directories to scan/compile)");
  }
  return project;
}

function compileProject(_) {
  var base = process.cwd();
  var project = getProject();
  project.verbose = 1;
  var dirs = []; // already scanned cache to prevent recursion.
  project.dirs.forEach(function(file) {
    compileDir(file, project, dirs);
  });
}

function compileDir(dir, project, dirs) {
  dirs = dirs || []
  var realdir = fs.realpathSync(dir);
  if (dirs.indexOf(realdir) == -1) {
    dirs.push(realdir);
    
    var files = fs.readdirSync(realdir);
    files.forEach(function(file) {

      var full = realdir + '/' + file;
      var stat = fs.statSync(full);
      if (stat.isDirectory() && (project.directoryIgnorelist || directoryIgnoreList).indexOf(file) == -1) {
        compileDir(realdir + '/' + file, project, dirs);
      } else if (stat.isFile()) {
        compileFile(full, project);
      }
    });
    return files;
  }
  return [];
}

module.exports = {
  getProject: getProject,
  compileFile: compileFile,
  compileProject: compileProject
};












function parseShebang(content) {
  if (content[0] === '#' && content[1] === '!') {
    var n = content.indexOf("\n");
    var le = "\n";
    if (n != -1) {
      var shebang = content.substr(0, n);
      if (shebang[shebang.length-1] == "\r") {
        le = "\r\n";
        shebang = shebang.substr(0, shebang.length-1);
      }
      content = content.substr(n+1);
      return [shebang, content, le];
    }
  }
  return ['', content, ''];
}
function mtime(fname) {
  try {
    return fs.statSync(fname).mtime;
  }
  catch (ex) {
    return 0;
  }
}
