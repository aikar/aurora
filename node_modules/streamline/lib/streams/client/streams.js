/*** Generated by streamline 0.1.44 - DO NOT EDIT ***/ "use strict"; var __g=typeof global!=='undefined'?global:window;__g=(__g.__streamline||(__g.__streamline={}));__g.setEF=__g.setEF||function(e,f){e.__frame = e.__frame||f};var __srcName='streamline/lib/streams/client/streams_.js'; function __func(_, __this, __arguments, fn, index, frame, body){ if (!_) { return __future.call(__this, fn, __arguments, index); } frame.file = __srcName; frame.prev = __g.frame; __g.frame = frame; try { body(); } catch (e) { __g.setEF(e, frame.prev); __propagate(_, e); } finally { __g.frame = frame.prev; } } function __cb(_, frame, offset, col, fn){ frame.offset = offset; frame.col = col; var ctx = __g.context; return function ___(err, result){ var oldFrame = __g.frame; __g.frame = frame; __g.context = ctx; try { if (err) { __g.setEF(err, frame); return _(err); } return fn(null, result); } catch (ex) { __g.setEF(ex, frame); return __propagate(_, ex); } finally { __g.frame = oldFrame; } } } function __future(fn, args, i){ var done, err, result; var cb = function(e, r){ done = true; err = e, result = r; }; args = Array.prototype.slice.call(args); args[i] = function ___(e, r){ cb(e, r); }; fn.apply(this, args); return function ___(_){ if (done) _.call(this, err, result); else cb = _.bind(this); } .bind(this); } function __propagate(_, err){ try { _(err); } catch (ex) { __trap(ex); } } function __trap(err){ if (err) { if (__g.context && __g.context.errorHandler) __g.context.errorHandler(err); else console.error("UNCAUGHT EXCEPTION: " + err.message + "\n" + err.stack); } } function DataBuffer(options) {

















 var _chunks = [];

 this.read = function read__1(_, len) { var chunks, total, chunk; var __frame = { name: "read__1", line: 21 }; return __func(_, this, arguments, read__1, 0, __frame, function __$read__1() {
 if ((len < 0)) {
 len = Infinity; } ;
 if ((len == 0)) {
 return _(null, ""); } ;
 chunks = []; total = 0;
 while ((total < len)) {
 chunk = _chunks.splice(0, 1)[0];
 if (!chunk) {
 return _(null, ((chunks.length == 0) ? null : chunks.join(""))); } ;
 if (((total + chunk.length) <= len)) {
 chunks.push(chunk);
 total += chunk.length; }
 else {
 chunks.push(chunk.substring(0, (len - total)));
 _chunks.splice(0, 0, chunk.substring((len - total)));
 total = len; } ; };


 return _(null, chunks.join("")); }); };




 this.readAll = function readAll__2(_) { var __this = this; var __frame = { name: "readAll__2", line: 45 }; return __func(_, this, arguments, readAll__2, 0, __frame, function __$readAll__2() {
 return __this.read(__cb(_, __frame, 1, 9, _), -1); }); };




 this.unread = function(chunk) {
 _chunks.splice(0, 0, chunk);
 return this; };


 this.write = function write__3(_, data, enc) { var __this = this; var __frame = { name: "write__3", line: 56 }; return __func(_, this, arguments, write__3, 0, __frame, function __$write__3() {
 _chunks.push(data); return _(null, __this); }); };



 this.end = function(data, enc) {
 if (data) {
 _chunks.push(data); };
 return this; };


 this.contents = function() {
 return _chunks.join(""); };};



function HttpError(statusCode, message) {
 this.statusCode = statusCode;
 this.message = message;
 this.stack = new Error().stack;};


function _fixHttpClientOptions(options) {
 if (!options) {
 throw new Error("request error: no options") };
 if ((typeof options === "string")) {
 options = { url: options }; };
 return options;};



















function HttpClientRequest(options) {
 options = _fixHttpClientOptions(options);
 DataBuffer.call(this, options);
 var _xhr;
 this.response = function(callback) {
 if (!callback) {
 return __future.call(this, this.response, arguments, 0) };
 $.ajax({
 url: options.url,
 headers: options.headers,
 type: options.method,
 data: this.contents(),
 dataType: "text",
 beforeSend: function(xhr) {
 _xhr = xhr; },

 success: function(data, statusText, xhr) {
 callback(null, new HttpClientResponse(data, xhr)); },

 error: function(xhr, statusText, message) {
 if ((statusText == "error")) {
 callback(new HttpError(xhr.status, ((statusText + ": ") + message))); } else {

 callback(new HttpError(400, ((statusText + ": ") + message))); }; } }); };



 this.abort = function() {
 (_xhr && _xhr.abort());
 _xhr = null; };};



function HttpClientResponse(data, xhr) {
 DataBuffer.call(this);
 this.end(data);
 this.statusCode = xhr.status;
 this.headers = { };
 var self = this;
 xhr.getAllResponseHeaders().replace(/\r\n/g, "\n").split("\n").forEach(function(header) {
 var pair = header.split(":");
 self.headers[pair[0].toLowerCase()] = (pair[1] && pair[1].trim()); });};



exports.httpRequest = function(options) {
 return new HttpClientRequest(options);};