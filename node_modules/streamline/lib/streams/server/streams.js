/*** Generated by streamline 0.1.44rt1 - DO NOT EDIT ***/ "use strict"; var __rt=require('streamline/lib/compiler/runtime')(__filename),__propagate=__rt.__propagate,__defineGetter__=__rt.__defineGetter__,__defineSetter__=__rt.__defineSetter__,__func=__rt.__func,__cb=__rt.__cb,__trap=__rt.__trap,__future=__rt.__future,__setEF=__rt.__setEF,__g=__rt.__g; var parseUrl = require("url").parse;


























function _reply(callback, err, value) {
 try {
 callback(err, value);
 } catch (ex) {
 __propagate(callback, ex); };};



function checkOpen(emitter) {
 if (!emitter) {
 throw new Error("invalid operation on closed stream") };};


function wrapProperties(constr, writable, props) {
 props.forEach(function(name) {
 constr.prototype.__defineGetter__(name, function() {
 return this.emitter[name]; }); });


 (writable && props.forEach(function(name) {
 constr.prototype.__defineSetter__(name, function(val) {
 this.emitter[name] = val;
 return this; }); }));};




function wrapMethods(constr, methods) {
 methods.forEach(function(name) {
 constr.prototype[name] = function() {
 return this.emitter[name].apply(this.emitter, arguments); }; });};




function wrapChainMethods(constr, methods) {
 methods.forEach(function(name) {
 constr.prototype[name] = function() {
 this.emitter[name].apply(this.emitter, arguments);
 return this; }; });};




function wrapEvents(constr, events) {
 constr.prototype.events = ((constr.prototype.events || [])).concat(events);};










function Emitter(emitter) {
 var self = this;
 emitter.on("close", function(err) {
 _onClose(); });

 function trackClose() {
 emitter = null; };

 var _onClose = trackClose;

 this.close = function close__1(_) { var __frame = { name: "close__1", line: 94 }; return __func(_, this, arguments, close__1, 0, __frame, function __$close__1() {















 return (function(callback) { if (!emitter) { return _reply(callback) }; var close = (emitter.close || emitter.destroySoon); if ((typeof close !== "function")) { return _reply(callback) }; _onClose = function() { emitter = null; _onClose = trackClose; _reply(callback); }; if (self.doesNotEmitClose) { emitter.emit("close"); } ; close.call(emitter); })(__cb(_, __frame, 16, 3, _)); }); };



 this.__defineGetter__("emitter", function() {
 return emitter; });




 this.unwrap = function() {
 var result = emitter;
 (emitter && emitter.events.forEach(function(event) {

 emitter.removeAllListeners(event); }));

 emitter = null;
 return result; };};










function ReadableStream(emitter, options) {
 Emitter.call(this, emitter);
 options = (options || { });
 var _low = Math.max((options.lowMark || 0), 0);
 var _high = Math.max((options.highMark || 0), _low);
 var _paused = false;
 var _current = 0;
 var _chunks = [];
 var _error;
 var _done = false;
 var _encoding;

 emitter.on("error", function(err) {
 _onData(err); });

 emitter.on("data", function(chunk) {
 _onData(null, chunk); });

 emitter.on("end", function() {
 _onData(null, null); });

 function trackData(err, chunk) {
 if (!emitter) {
 return };
 if (err) {
 _error = err; } else {
 if (chunk) {
 _chunks.push(chunk);
 _current += chunk.length;
 if (((((_current > _high) && !_paused) && !_done) && !_error)) {
 emitter.pause();
 _paused = true; } ; }


 else _done = true;  }; };


 var _onData = trackData;

 function readChunk(callback) {
 if ((_chunks.length > 0)) {
 var chunk = _chunks.splice(0, 1)[0];
 _current -= chunk.length;
 if (((((_current <= _low) && _paused) && !_done) && !_error)) {
 emitter.resume();
 _paused = false; } ;

 return _reply(callback, null, chunk); }
 else if (_done) {
 if (_paused) {
 try {
 emitter.resume();
 _paused = false;
 } catch (e) {  }; } ;


 return _reply(callback, null, null); }

 else if (_error) {
 return _reply(callback, _error); }


 else _onData = function(err, chunk) {
 if (err) {
 _error = err; } else {
 if (!chunk) {
 _done = true; } };
 _onData = trackData;
 _reply(callback, err, chunk); };   ; };



 function concat(chunks, total) {
 if (_encoding) {
 return chunks.join("") };
 if ((chunks.length == 1)) {
 return chunks[0] };
 var result = new Buffer(total);
 chunks.reduce(function(val, chunk) {
 chunk.copy(result, val);
 return (val + chunk.length);
 }, 0);
 return result; };




 this.setEncoding = function(enc) {
 checkOpen(emitter);
 _encoding = enc;
 if (enc) {
 emitter.setEncoding(enc); };
 return this; };







 this.read = function read__1(_, len) { var chunks, total, chunk, __this = this; var __frame = { name: "read__1", line: 238 }; return __func(_, this, arguments, read__1, 0, __frame, function __$read__1() {
 if (!emitter) {
 return _(null, null); } ; return (function __$read__1(__then) {
 if ((len == null)) {
 return readChunk(__cb(_, __frame, 4, 10, _)); } else { __then(); } ; })(function __$read__1() {
 if ((len < 0)) {
 len = Infinity; } ;
 if ((len == 0)) {
 return _(null, (_encoding ? "" : new Buffer(0))); } ;
 chunks = []; total = 0; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$read__1() { __more = false;
 var __4 = (total < len); if (__4) {
 return readChunk(__cb(_, __frame, 11, 15, function ___(__0, __2) { chunk = __2;
 if (!chunk) {
 return _(null, ((chunks.length == 0) ? null : concat(chunks, total))); } ;
 if (((total + chunk.length) <= len)) {
 chunks.push(chunk);
 total += chunk.length; }
 else {
 chunks.push(chunk.slice(0, (len - total)));
 __this.unread(chunk.slice((len - total)));
 total = len; } ; while (__more) { __loop(); }; __more = true; })); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(function __$read__1() {


 return _(null, concat(chunks, total)); }); }); }); };




 this.readAll = function readAll__2(_) { var __this = this; var __frame = { name: "readAll__2", line: 266 }; return __func(_, this, arguments, readAll__2, 0, __frame, function __$readAll__2() {
 return __this.read(__cb(_, __frame, 1, 9, _), -1); }); };




 this.unread = function(chunk) {
 if (chunk) {
 _chunks.splice(0, 0, chunk);
 _current += chunk.length; } ;

 return this; };};



exports.ReadableStream = ReadableStream;
wrapEvents(ReadableStream, ["error","data","end","close",]);








function WritableStream(emitter, options) {
 Emitter.call(this, emitter);
 options = (options || { });
 var _onDrain;

 emitter.on("drain", function() {
 (_onDrain && _onDrain()); });


 function _drain(callback) {
 _onDrain = function() {
 _onDrain = null;
 _reply(callback); }; };










 this.write = function write__1(_, data, enc) { var __this = this; var __frame = { name: "write__1", line: 314 }; return __func(_, this, arguments, write__1, 0, __frame, function __$write__1() {
 checkOpen(emitter); return (function __$write__1(__then) {
 if (!emitter.write(data, enc)) {
 return _drain(__cb(_, __frame, 3, 3, __then)); } else { __then(); } ; })(function __$write__1() { return _(null, __this); }); }); };





 this.end = function(data, enc) {
 checkOpen(emitter);
 emitter.end(data, enc);
 return this; };};



exports.WritableStream = WritableStream;
wrapEvents(WritableStream, ["drain","close",]);

function _getEncoding(headers) {
 var comps = ((headers["content-type"] || "text/plain")).split(";");
 var ctype = comps[0];
 for (var i = 1; (i < comps.length); i++) {
 var pair = comps[i].split("=");
 if (((pair.length == 2) && (pair[0].trim() == "charset"))) {
 return pair[1].trim() }; };

 if (((ctype.indexOf("text") >= 0) || (ctype.indexOf("json") >= 0))) {
 return "utf8" };
 return null;};











function HttpServerRequest(req, options) {
 ReadableStream.call(this, req, options);
 this._request = req;
 this.setEncoding(_getEncoding(req.headers));};


exports.HttpServerRequest = HttpServerRequest;
HttpServerRequest.prototype.doesNotEmitClose = true;










wrapProperties(HttpServerRequest, true, ["method","url","headers","trailers","httpVersion","connection","socket",]);









function HttpServerResponse(resp, options) {
 WritableStream.call(this, resp, options);
 this._response = resp;};


exports.HttpServerResponse = HttpServerResponse;
HttpServerResponse.prototype.doesNotEmitClose = true;









wrapChainMethods(HttpServerResponse, ["writeContinue","writeHead","setHeader","removeHeader","addTrailers",]);
wrapMethods(HttpServerResponse, ["getHeader",]);
wrapProperties(HttpServerResponse, true, ["statusCode",]);

function _fixHttpServerOptions(options) {
 options = (options || { });
 options.module = require((options.secure ? "https" : "http"));
 return options;};











function HttpServer(requestListener, options) {
 var self = this;
 options = _fixHttpServerOptions(options);
 var server = options.module.createServer(function(request, response) {
 return requestListener(new HttpServerRequest(request, options), new HttpServerResponse(response, options), function(err) {
 if (err) {
 response.writeHead(500, { "Content-Type": "text/plain" });
 response.end(((err.message + "\n") + err.stack)); } ; }); });



 Emitter.call(this, server);




 this.listen = function listen__1(_, args) { var __arguments = arguments; var __frame = { name: "listen__1", line: 434 }; return __func(_, this, arguments, listen__1, 0, __frame, function __$listen__1() {
 args = Array.prototype.slice.call(__arguments, 1);





 return (function(callback) { args.push(function() { _reply(callback, null, self); }); server.listen.apply(server, args); })(__cb(_, __frame, 7, 3, _)); }); };};



exports.HttpServer = HttpServer;









function HttpClientResponse(resp, options) {
 ReadableStream.call(this, resp, options);
 this._response = resp;
 this.setEncoding(_getEncoding(resp.headers));};










wrapProperties(HttpClientResponse, false, ["statusCode","httpVersion","headers","trailers",]);





HttpClientResponse.prototype.checkStatus = function(statuses) {
 if ((typeof statuses === "number")) {
 statuses = [statuses,]; };
 if ((statuses.indexOf(this.statusCode) < 0)) {
 throw new Error(("invalid status: " + this.statusCode)) };
 return this;};


function _fixHttpClientOptions(options) {
 if (!options) {
 throw new Error("request error: no options") };
 if ((typeof options === "string")) {
 options = { url: options }; };
 if (options.url) {
 var parsed = parseUrl(options.url);
 options.protocol = parsed.protocol;
 options.host = parsed.hostname;
 options.port = parsed.port;
 options.path = (parsed.pathname + ((parsed.query ? ("?" + parsed.query) : ""))); };

 options.protocol = (options.protocol || "http:");
 options.port = (options.port || (((options.protocol === "https:") ? 443 : 80)));
 options.path = (options.path || "/");
 if (!options.host) {
 throw new Error("request error: no host") };
 options.method = (options.method || "GET");
 options.headers = (options.headers || { });
 options.module = require(options.protocol.substring(0, (options.protocol.length - 1)));
 if ((options.user != null)) {

 var token = ((options.user + ":") + ((options.password || "")));
 token = new Buffer(token, "utf8").toString("base64");
 options.headers.Authorization = ("Basic " + token); };


 if (options.proxy) {
 if ((typeof options.proxy === "string")) {
 options.proxy = parseUrl(options.proxy);
 options.proxy.host = options.proxy.hostname; } ;

 options.proxy.port = (options.proxy.port || options.port);
 if (!options.proxy.host) {
 throw new Error("proxy configuration error: no host") };
 options.path = (((((options.protocol + "//") + options.host) + ":") + options.port) + options.path);
 options.headers.host = options.host;
 options.host = options.proxy.host;
 options.port = options.proxy.port; };


 return options;};



















function HttpClientRequest(options) {
 options = _fixHttpClientOptions(options);
 var _request = options.module.request(options, function(resp) {
 _onResponse(null, (resp && new HttpClientResponse(resp, options))); });

 WritableStream.call(this, _request, options);
 var _response;
 var _error;
 var _done = false;

 _request.on("error", function(err) {

 (!_response && _onResponse(err)); });

 function trackResponse(err, resp) {
 _done = true;
 _error = err;
 _response = resp; };


 var _onResponse = trackResponse;


 this.response = function response__1(_) { var __frame = { name: "response__1", line: 567 }; return __func(_, this, arguments, response__1, 0, __frame, function __$response__1() {







 return (function(callback) { if (_done) { return _reply(callback, _error, _response); } else { _onResponse = function(err, resp) { _reply(callback, err, resp); }; }; })(__cb(_, __frame, 8, 3, _)); }); };};





wrapChainMethods(HttpClientRequest, ["abort",]);

exports.httpRequest = function(options) {
 return new HttpClientRequest(options);};












function NetStream(emitter, options) {
 ReadableStream.call(this, emitter, (options.read || options));
 WritableStream.call(this, emitter, (options.write || options));};


exports.NetStream = NetStream;

var net;











exports.tcpClient = function(port, host, options) {
 host = (host || "localhost");
 options = (options || { });
 return new NetClient(options, port, host);};

exports.socketClient = function(path, options) {
 options = (options || { });
 return new NetClient(options, path);};


function NetClient(options, args) {
 args = Array.prototype.slice.call(arguments, 1);
 net = (net || require("net"));
 var _connection = net.createConnection.apply(net, args);
 var _error;
 var _done = false;

 _connection.on("error", function(err) {

 _onConnect(err); });

 _connection.on("connect", function() {
 _onConnect(null); });

 function trackConnect(err) {
 _done = true;
 _error = err; };


 var _onConnect = trackConnect;



 this.connect = function connect__1(_) { var __frame = { name: "connect__1", line: 649 }; return __func(_, this, arguments, connect__1, 0, __frame, function __$connect__1() {







 return (function(callback) { if (_done) { return _reply(callback, _error, new NetStream(_connection, options)); } else { _onConnect = function(err) { _reply(callback, err, new NetStream(_connection, options)); }; }; })(__cb(_, __frame, 8, 3, _)); }); };};